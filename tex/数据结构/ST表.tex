\section{ST表}
RMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。
解决 RMQ 问题的主要方法有两种，分别是 ST 表和线段树。本文主要讲 ST 表。
\subsection{ST表}
    ST表基于\textbf{倍增}思想。\\
    令$dp[i][j]$表示从$i$开始的长度为$2^j$的区间的最大/小值。
    $$dp[i][j] = max(dp[i][j-1], dp[i+(1<<(j-1))][j-1])$$
    查询时，令$j=\lfloor \log_{2}{(r-l+1)} \rfloor$，即长度为$2^j$，此长度$\frac{r-l+1}{2} \le len \le r-l+1$，
    于是可以用两个相同长度$(2^j)$的区间覆盖（中间有重复不影响结果）\\
    一开始可以对所有$1\le i\le n$初始化，其中$Log2[1]=0$；$i\ge 2,Log2[i]=Log2[i/2]+1$
\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
int n, a[N];
int dp[N][20];
int Log2[N];

void init() {
    Log2[1] = 0;
    for (int i = 2; i < N; ++i)
        Log2[i] = Log2[i / 2] + 1;
}

int main() {
    init();
    int i, j, m, l, r, k;
    while (scanf("%d%d", &n, &m) != EOF) {
        for (i = 1; i <= n; i++)
            scanf("%d", &a[i]);
        for (i = 1; i <= n; i++)
            dp[i][0] = a[i];
        k = Log2[n];
        for (j = 1; j <= k; j++)
            for (i = 1; i <= n - (1 << j) + 1; i++)
                dp[i][j] = max(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1]);
        for (i = 1; i <= m; i++) {
            scanf("%d%d", &l, &r);
            k = Log2[r - l + 1];
            printf("%d\n", max(dp[l][k], dp[r - (1 << k) + 1][k]));
        }
    }

    return 0;
}
\end{lstlisting}
\subsection{LCA(最近公共祖先)}
    $f[i][j]$ 表示 $i$ 的第 $2^j$ 个祖先, 如 $f[i][0]$ 表示$i$的父节点\\
    状态转移 $f[i][j] = f[f[i][j-1]][j-1]$\\\\
    查询:\\
    设 $dep[x] > dep[y]$\\
    令 $x$ 跳到和 $y$ 同深度,\\
    若 $x == y$, 则就是 $x$.\\
    否则, $x$和$y$ 一起向上跳,\\
    每次跳 $2^j$ 步$(j:20->0)$, 其始终保证 $x\neq y$,\\
    最后结果就是 $f[x][0]$ 或 $f[y][0]$
\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;
const int N = 5e5 + 10;

struct Edge {
    int u, v, next;
} e[N * 2];
int head[N], ecnt;

void addEdge(int u, int v) {
    e[ecnt].u = u, e[ecnt].v = v, e[ecnt].next = head[u];
    head[u] = ecnt++;
}

int n, m, s;
int f[N][25], dep[N];

void dfs(int u, int pa) {
    dep[u] = dep[pa] + 1;
    f[u][0] = pa;
    int i;
    for (i = 1; i <= 20; i++)
        f[u][i] = f[f[u][i - 1]][i - 1];
    for (i = head[u]; i != -1; i = e[i].next) {
        if (e[i].v == pa)
            continue;
        dfs(e[i].v, u);
    }
}

int lca(int x, int y) {
    int i;
    // 令x的深度大于y
    if (dep[x] < dep[y])
        swap(x, y);
    // 先令x跳到和y同样深度
    for (i = 20; i >= 0; i--) {
        if (dep[f[x][i]] >= dep[y])
            x = f[x][i];
        if (x == y)
            return x;
    }
    // 一起跳
    for (i = 20; i >= 0; i--) {
        if (f[x][i] != f[y][i]) {
            x = f[x][i];
            y = f[y][i];
        }
    }
    return f[x][0];
}

int main() {
    int i, u, v;
    scanf("%d%d%d", &n, &m, &s);
    for (i = 0; i <= n; i++)
        head[i] = -1;
    for (i = 1; i <= n - 1; i++) {
        scanf("%d%d", &u, &v);
        addEdge(u, v);
        addEdge(v, u);
    }
    dep[0] = 0;
    dfs(s, 0);
    for (i = 1; i <= m; i++) {
        scanf("%d%d", &u, &v);
        printf("%d\n", lca(u, v));
    }

    return 0;
}
\end{lstlisting}