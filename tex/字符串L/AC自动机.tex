\section{AC自动机}
    \subsection{概述}
        AC 自动机是 \textbf{以TRIE的结构为基础} ，结合 \textbf{KMP 的思想} 建立的。\\\\
        简单来说，建立一个 AC 自动机有两个步骤：\\
        1.  基础的 TRIE 结构：将所有的模式串构成一棵 $Trie$ 。\\
        2.  KMP 的思想：对 $Trie$ 树上所有的结点构造失配指针。\\\\
        然后就可以利用它进行多模式匹配了。
    \subsection{代码}
\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;
const int N = 1e6 + 10;

struct AC {
    int tr[N][26], cnt;  // 字典树/自动机; 节点数
    int exist[N];        // 标记以该节点为结尾的字符串有几个(因为题中说了输入可能有相同的模式串)
    // 构建最初的字典树
    void insert(char s[], int l) {
        int p = 0, i;  // p表示当前所处节点，p=0时为起点(空串)
        for (i = 0; i < l; i++) {
            int c = s[i] - 'a';
            if (!tr[p][c])
                tr[p][c] = ++cnt;  // 如果没有就添加节点
            p = tr[p][c];          // 每一步结束p都会指向最后的已存在的节点
        }
        exist[p]++;  // 记录以该节点为结尾的字符串的个数
    }

    int fail[N];   // fail指针
    queue<int> q;  // 用于bfs
    // 构建自动机及fail指针，此时tr就进化为一个自动机了
    void build() {
        int i;
        // 队列中一开始是根节点的儿子节点们，儿子们的fail指向根节点(0)
        for (i = 0; i < 26; i++)
            if (tr[0][i])
                q.push(tr[0][i]);
        // 开始bfs
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (i = 0; i < 26; i++) {
                // 与kmp自动机中的dp思想很像
                if (tr[u][i])
                    fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]);
                else
                    tr[u][i] = tr[fail[u]][i];
            }
        }
    }

    bool vis[N];  // 自动机是否已经匹配过
    int query(char s[], int l) {
        int u = 0, res = 0, i, j;
        for (i = 0; i < l; i++) {
            u = tr[u][s[i] - 'a'];  // 转移到下一个状态
            // 检查每一个后缀是否可以匹配，且对于每个模式串只匹配一次
            for (j = u; !vis[j]; j = fail[j])
                res += exist[j], vis[j] = 1;
        }
        return res;
    }
} ac;

int n;
char s[N];

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int i;
    cin >> n;
    for (i = 1; i <= n; i++) {
        cin >> s;
        ac.insert(s, strlen(s));
    }
    ac.build();

    cin >> s;
    cout << ac.query(s, strlen(s)) << endl;

    return 0;
}
\end{lstlisting}
    \subsection{洛谷 P5357 【模板】AC自动机（二次加强版）}
        给你一个文本串$S$和$n$个模式串$T_{1..n}$，请你分别求出每个模式串$T_i$在$S$中出现的次数。\\\\
        解法：AC自动机，树形DP
\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;
const int N = 2e5 + 10, M = 2e6 + 10;

int n;
int mp[N];
string s[N];       // 模式串
vector<int> g[N];  // 图
int ans[N];
bool vis[N];
char t[M];

struct AC {
    int tr[N][26], cnt;  // 字典树/自动机; 节点数
    bool exist[N];       // 标记以该节点为结尾的字符串是否存在
    // 构建最初的字典树
    int insert(string s, int l) {
        int p = 0, i;  // p表示当前所处节点，p=0时为起点(空串)
        for (i = 0; i < l; i++) {
            int c = s[i] - 'a';
            if (!tr[p][c])
                tr[p][c] = ++cnt;  // 如果没有就添加节点
            p = tr[p][c];          // 每一步结束p都会指向最后的已存在的节点
        }
        exist[p] = 1;  // 标记以该节点为结尾的字符串存在
        return p;
    }

    int fail[N];   // fail指针
    queue<int> q;  // 用于bfs
    // 构建自动机及fail指针，此时tr就进化为一个自动机了
    void build() {
        int i;
        // 队列中一开始是根节点的儿子节点们，儿子们的fail指向根节点(0)
        for (i = 0; i < 26; i++)
            if (tr[0][i])
                q.push(tr[0][i]);
        // 开始bfs
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            g[fail[u]].push_back(u);  // 按fail指针反向构建树
            for (i = 0; i < 26; i++) {
                // 与kmp自动机中的dp思想很像
                if (tr[u][i])
                    fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]);
                else
                    tr[u][i] = tr[fail[u]][i];
            }
        }
    }

    void query(char s[], int l) {
        int u = 0, i, j;
        for (i = 0; i < l; i++) {
            u = tr[u][s[i] - 'a'];  // 转移到下一个状态（最大匹配后缀，所以下面还要跳转至更短的后缀）
            ++ans[u];
        }
    }
} ac;

// 树形DP思想，将长串出现的次数累加至其fail指针能跳到的短串
void dfs(int u) {
    if (vis[u])
        return;
    vis[u] = 1;
    for (auto v : g[u]) {
        dfs(v);
        ans[u] += ans[v];
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int i;
    cin >> n;
    for (i = 1; i <= n; i++) {
        cin >> s[i];
        mp[i] = ac.insert(s[i], s[i].length());
    }
    ac.build();
    cin >> t;
    ac.query(t, strlen(t));
    for (i = 0; i <= ac.cnt; i++)
        dfs(i);
    for (i = 1; i <= n; i++)
        cout << ans[mp[i]] << endl;

    return 0;
}
\end{lstlisting}
    \subsection{子矩阵匹配}
        给定一个$n*m$的大矩阵s[][]和一个$x*y$的小矩阵t[][]，问小矩阵在大矩阵中出现的次数。\\\\
        首先对小矩阵t[][]构建一个AC自动机，然后将大矩阵的每一行丢到AC自动机里跑，并求出每一个s[i][j]处匹配到自动机的哪个节点记录到pos[i][j]。
        接下来只要将s[][]的每一个位置当作起点，竖着向下匹配即可。
\begin{lstlisting}
    /*
子矩阵匹配
AC自动机
*/

#include <bits/stdc++.h>

using namespace std;
const int N = 1e3 + 10, M = 1e2 + 10;

char s[N][N], t[M][M];
int n, m, x, y;
int pos[N][N];

// 对AC自动机全面初始化
struct AC {
    void init() {
        int i;
        for (i = 0; i <= cnt; i++) {
            memset(tr[i], 0, sizeof(tr[i]));
            memset(exist[i], 0, sizeof(exist[i]));
            fail[i] = 0;
        }
        while (!q.empty())
            q.pop();
        cnt = 0;
    }
    int tr[M * M][26], cnt;  // 字典树/自动机; 节点数
    bool exist[M * M][200];
    // 构建最初的字典树
    void insert(char s[], int l, int id) {
        int p = 0, i;  // p表示当前所处节点，p=0时为起点(空串)
        for (i = 0; i < l; i++) {
            int c = s[i] - 'a';
            if (!tr[p][c])
                tr[p][c] = ++cnt;  // 如果没有就添加节点
            p = tr[p][c];          // 每一步结束p都会指向最后的已存在的节点
        }
        exist[p][id] = 1;
    }

    int fail[M * M];  // fail指针
    queue<int> q;     // 用于bfs
    // 构建自动机及fail指针，此时tr就进化为一个自动机了
    void build() {
        int i;
        // 队列中一开始是根节点的儿子节点们，儿子们的fail指向根节点(0)
        for (i = 0; i < 26; i++)
            if (tr[0][i])
                q.push(tr[0][i]);
        // 开始bfs
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (i = 0; i < 26; i++) {
                // 与kmp自动机中的dp思想很像
                if (tr[u][i])
                    fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]);
                else
                    tr[u][i] = tr[fail[u]][i];
            }
        }
    }

    void query(char s[], int l, int pos[]) {
        int u = 0, i, j;
        for (i = 0; i < l; i++) {
            u = tr[u][s[i] - 'a'];  // 转移到下一个状态（最大匹配后缀，所以下面还要跳转至更短的后缀）
            pos[i] = u;
        }
    }
} ac;

int solve() {
    int i, j, k, ans = 0;
    for (i = 1; i <= n; i++) {
        for (j = 0; j < m; j++) {
            bool ok = 1;
            for (k = 0; k < x; k++) {
                if (!ac.exist[pos[i + k][j]][k + 1]) {
                    ok = 0;
                    break;
                }
            }
            ans += ok;
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int T, i, j, k;
    scanf("%d", &T);
    while (T--) {
        scanf("%d%d", &n, &m);
        for (i = 1; i <= n; i++)
            scanf("%s", s[i]);
        scanf("%d%d", &x, &y);
        for (i = 1; i <= x; i++)
            scanf("%s", t[i]);

        // 构建自动机
        for (i = 1; i <= x; i++)
            ac.insert(t[i], y, i);
        ac.build();
        for (i = 1; i <= n; i++)
            ac.query(s[i], m, pos[i]);

        // 求
        int ans = solve();
        printf("%d\n", ans);

        // 初始化
        ac.init();
    }

    return 0;
}
\end{lstlisting}