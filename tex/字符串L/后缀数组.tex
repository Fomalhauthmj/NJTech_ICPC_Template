\section{后缀数组}
    \subsection{概述}
        后缀数组（Suffix Array）主要是两个数组： $sa$ 和 $rk$ 。\\
        其中， $sa[i]$ 表示将所有后缀排序后第 $i$ 小的后缀的编号。 $rk[i]$ 表示后缀 $i$ 的排名。\\
        这两个数组满足性质： $sa[rk[i]]=rk[sa[i]]=i$ 。
    \subsection{后缀数组求法}
        用倍增的思想，再用基数排序优化。
\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;
const int N = 1e6 + 10;  // 拼接开双倍

int n;
char s[N];
int sa[N], rk[N];
int cnt[N];  // 计数=>前缀和

struct Tri {
    int key[2], id;
    bool operator<(const Tri& rhs) const {
        return key[0] != rhs.key[0] ? key[0] < rhs.key[0] : key[1] < rhs.key[1];
    }
} tri[N], b[N];

void getSA() {
    int i, w, k, mx;
    for (i = 1; i <= n; i++)
        rk[i] = s[i];  // 初始化大小
    for (w = 1; w < n; w <<= 1) {
        for (i = 1; i <= n; ++i)
            tri[i] = {rk[i], i + w <= n ? rk[i + w] : 0, i};  // 倍增rk
        for (k = 1; k >= 0; --k) {                            // 基数排序
            memset(cnt, 0, sizeof(cnt)), mx = 0;
            for (i = 1; i <= n; ++i)
                ++cnt[tri[i].key[k]], mx = max(mx, tri[i].key[k]);
            for (i = 1; i <= mx; ++i)
                cnt[i] += cnt[i - 1];
            for (i = n; i >= 1; --i)
                b[cnt[tri[i].key[k]]--] = tri[i];
            memcpy(tri, b, sizeof(tri));
        }
        for (rk[tri[1].id] = k = 1, i = 2; i <= n; ++i) {
            if (tri[i - 1] < tri[i])  // 去重
                ++k;
            rk[tri[i].id] = k;  // 得出当前的rk
        }
    }
    for (i = 1; i <= n; ++i)  // 由rk算后缀数组sa
        sa[rk[i]] = i;
}

int main() {
    int i;
    scanf("%s", s + 1);
    n = strlen(s + 1);
    s[n + 1] = 0;  // 串的终结符，不同情况下值不一样，要求输入中没有且比输入值都小
    getSA();
    for (i = 1; i <= n; i++)
        printf("%d ", rk[i]);
    printf("\n");
    for (i = 1; i <= n; i++)
        printf("%d ", sa[i]);
    printf("\n");

    return 0;
}

/*
aabaaaab
4 6 8 1 2 3 5 7 
4 5 6 1 7 2 8 3 
*/
\end{lstlisting}
    \subsection{循环串的排序问题}
        \subsubsection{题目描述}
            给你一个串S，S绕成一圈，然后S就有了很多种读法。现在要求你将所有读法的字符串排序，读出最后一列字符。\\
            例如‘JSOI07’，可以读作： JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 把它们按照字符串的大小排序： 07JSOI 7JSOI0 I07JSO JSOI07 OI07JS SOI07J 读出最后一列字符：I0O7SJ
        \subsubsection{解法}
            将字符串S复制一份变成SS，对SS求后缀数组，则得到所有读法的排名。但是要注意，若$sa[i]>n$(n是S的长度)，则该读法是无效的，应直接跳过。\\
            拼接后的字符串SS的每一个后缀长度并不一定刚好等于读出的长度n，为什么可以直接用后缀数组而无需修改呢？
            对于有效的读法（长度大于等于n），考虑两种情况：1.在比较长度不到n的时候已经发生不等，此时顺序显然是正确的；2.前n个字符都相等，后面发生了不等，其实后面的大小关系不影响结果，
            因为前n个已经相等了，说明这两个读法是相等的，而他们的相对位置怎样都是可以的。
\begin{lstlisting}
    #include <bits/stdc++.h>

using namespace std;
const int N = 2e5 + 10;  // 拼接开双倍

int n;
char s[N];
int sa[N], rk[N];
int cnt[N];  // 计数=>前缀和

// getSA()

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int i;
    cin >> s + 1;
    n = strlen(s + 1);
    strncpy(s + 1 + n, s + 1, n);
    n *= 2;
    getSA();
    n /= 2;
    for (i = 1; i <= 2 * n; ++i)
        if (sa[i] <= n)
            cout << s[sa[i] + n - 1];
    cout << endl;

    return 0;
}
\end{lstlisting}
    \subsection{在字符串中找子串}
        任务是在线地在主串 $S$ 中寻找模式串 $T$ 。在线的意思是，我们已经预先知道知道主串 $S$ ，但是当且仅当询问时才知道模式串 $T$ 。我们可以先构造出 $S$ 的后缀数组，然后查找子串 $T$ 。若子串 $T$ 在 $S$ 中出现，它必定是 $S$ 的一些后缀的前缀。因为我们已经将所有后缀排序了，我们可以通过在 $sa$ 数组中二分 $T$ 来实现。比较子串 $T$ 和当前后缀的时间复杂度为 $O(|T|)$ ，因此找子串的时间复杂度为 $O(|T|\log |S|)$ 。注意，如果该子串在 $S$ 中出现了多次，每次出现都是在 $sa$ 数组中相邻的。因此出现次数可以通过再次二分找到，输出每次出现的位置也很轻松。\\\\
        因为强制在线，所以不能用AC自动机\\
        那这与KMP由什么区别呢？\\
        这里用KMP每次都要对模式串求pi，而后缀数组只要对主串求一次\\
        KMP复杂度：O(M+N)；后缀数组复杂度：O(MlogN)。\\
        显然，当m很小而n很大的时候后缀数组的优势就体现出来了
\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;
const int N = 1e2 + 10;  // 拼接开双倍

int n, m;         // s和t的长度
char s[N], t[N];  // 在主串s中在线的寻找t
int sa[N], rk[N];
int cnt[N];  // 计数=>前缀和

// getSA()

// 若s的后缀p大于t返回正数，小于返回负数，相等返回0
int cmp(int p) {
    int i;
    for (i = 1; i <= m && p <= n; ++p, ++i)
        if (s[p] != t[i])
            return s[p] - t[i];
    return i == m + 1 ? 0 : -1;
}

// 当前区间[l,r]，找等于模式串t的后缀的最大排名
int find1(int l, int r) {
    if (l > r)
        return 0;
    int mid = (l + r) / 2;
    int x = cmp(sa[mid]);
    if (x > 0)  // 后缀大于t
        return find1(l, mid - 1);
    else if (x < 0)
        return find1(mid + 1, r);
    else
        return max(mid, find1(mid + 1, r));
}

// 找小于模式串t的后缀的最大排名
int find2(int l, int r) {
    if (l > r)
        return 0;
    int mid = (l + r) / 2;
    int x = cmp(sa[mid]);
    if (x >= 0)  // 后缀大于等于t
        return find2(l, mid - 1);
    else  // 后缀小于t
        return max(mid, find2(mid + 1, r));
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int q;  // q次询问
    cin >> q >> (s + 1);
    n = strlen(s + 1);
    getSA();
    while (q--) {
        cin >> (t + 1);
        m = strlen(t + 1);
        int r1 = find1(1, n);
        int r2 = find2(1, n);
        int ans = r1 - r2;
        if (ans > 0)
            cout << ans << endl;
        else
            cout << 0 << endl;
    }

    return 0;
}
\end{lstlisting}
    \subsection{从字符串首尾取字符最小化字典序}
        题意：给你一个字符串，每次从首或尾取一个字符放到新字符串末尾，取完为止，问所有能够组成的字符串中字典序最小的一个。\\\\
        解法一：贪心+暴力，每次从两边向中间取字符，直到两个串不相等，则把小的那个全部加到新串末尾，如果到最后相遇都相等，则直接全取\\\\
        解法二：由于需要在原串后缀与反串后缀构成的集合内比较大小，可以将反串拼接在原串后，并在中间加上一个没出现过的字符（如 \#，代码中可以直接使用空字符），求后缀数组，即可O(1)完成这一判断。\\
\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;
const int N = 1e6 + 10;  // 拼接开双倍

int n;
char s[N], ans[N];
int sa[N], rk[N];
int cnt[N];  // 计数=>前缀和

// getSA()

int main() {
    int i, j, m, k;
    scanf("%d", &n);
    for (i = 1; i <= n; ++i) {
        char ch = getchar();
        while (!isalpha(ch))
            ch = getchar();
        s[i] = ch;
    }
    s[n + 1] = '#';
    for (i = 1; i <= n; ++i)
        s[n + 1 + i] = s[n + 1 - i];
    m = n, n = 2 * n + 1;
    getSA();

    i = 1, j = m + 2, k = 1;
    while (k <= m) {
        if (rk[i] < rk[j])
            ans[k++] = s[i++];
        else
            ans[k++] = s[j++];
    }

    for (i = 1; i <= m; ++i) {
        printf("%c", ans[i]);
        if (i % 80 == 0)
            printf("\n");
    }
    if ((i - 1) % 80)
        printf("\n");

    return 0;
}
\end{lstlisting}
    \subsection{height数组}
        \subsubsection{LCP（最长公共前缀）}
            两个字符串 $S$ 和 $T$ 的 LCP 就是最大的 $x$ ( $x\le \min(|S|, |T|)$ ) 使得 $S_i=T_i\ (\forall\ 1\le i\le x)$ 。\\
            下文中以 $lcp(i,j)$ 表示后缀 $i$ 和后缀 $j$ 的最长公共前缀（的长度）。
        \subsubsection{height数组的定义}
            $height[i]=lcp(sa[i],sa[i-1])$ ，即第 $i$ 名的后缀与它前一名的后缀的最长公共前缀。\\
            $height[1]$ 可以视作 $0$ 。
        \subsubsection{O(n) 求 height 数组需要的一个引理}
            这里先不给出这个引理是什么，主要是为了防止证明（推导）过程中混乱。\\
            首先要是搞清楚$height[i]$中的$i$是\textbf{排名}。我们令后缀$i-1$为$aAD$，其首字母为$a$，$|A|=height[rk[i-1]]-1$，$D$为剩余部分。
            这里$height[rk[i-1]]-1$看起来非常绕，其实$height[rk[i-1]]-1==lcp(sa[rk[i-1]],sa[rk[i-1]-1])-1$，这就变得清晰多了，
            $sa[rk[i-1]]$就表示后缀$i-1$，$sa[rk[i-1]-1]$表示排名比后缀$i-1$小$1$的后缀。那么$aA$其实就是后缀$i-1$和排名比后缀$i-1$小$1$的后缀
            的LCP，而$A$就是LCP拿掉首字母$a$。\\
            由于$sa[rk[i-1]-1]$与$sa[rk[i-1]]$有一段LCP为$aA$，所以我们可以令$sa[rk[i-1]-1]$为$aAB$，则$sa[rk[i-1]-1]+1$为$AB$，且$rank(AD)\ge rank(AB)+1$（由$rank$关系）。
            而由后缀$i-1$为$aAD$我们还可以知道后缀$i$为$AD$，我们令比后缀$i$排名小$1$的后缀为$X$即$X=sa[rk[i]-1]$，则我们有$rank(AD)==rank(X)+1$。
            由$rank(AD)\ge rank(AB)+1$和$rank(AD)==rank(X)+1$，我们可以得到$rank(AD)>rank(X)>=rank(AB)$，所以我们可以确定$X$一定含有前缀$A$，那我们就可以令$X=AC$，
            则$lcp(sa[rk[i]],sa[rk[i]-1]) \ge |A|$。\\
            最后，我们得到了这个\textbf{引理：$height[rk[i]] \ge height[rk[i-1]]-1$}。
        \subsubsection{实现}
\begin{lstlisting}
// O(n)求height数组
void getHeight() {
    int i, k;
    // 预处理height
    for (i = 1, k = 0; i <= n; ++i) {
        k -= k > 0;                               // ht[rk[i]] >= ht[rk[i]-1] - 1 且 ht[] >= 0
        while (s[i + k] == s[sa[rk[i] - 1] + k])  // 暴力求lcp
            ++k;
        ht[rk[i]] = k;
    }
}
\end{lstlisting}
    \subsection{height数组求两子串最长公共前缀}
        $lcp(sa[i],sa[j])=\min\{height[i+1..j]\}$ \\
        感性理解：如果 $height$ 一直大于某个数，前这么多位就一直没变过；反之，由于后缀已经排好序了，不可能变了之后变回来。\\
        严格证明可以参考[$2004$后缀数组 by. 徐智磊][1]。\\
        有了这个定理，求两子串最长公共前缀就转化为了 RMQ 问题 。\\\\
        如果我们要求后缀x和后缀y的lcp，设$rk[x]<rk[y]$，则$lcp(x,y)=\min\{height[rk[x]+1\dots rk[y]]\}$
\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;
const int N = 1e2 + 10;  // 拼接开双倍

int n;
char s[N];
int sa[N], rk[N];
int cnt[N];      // 计数=>前缀和
int ht[N];       // height数组，ht[排名]
int rmq[N][20];  // RMQ，rmq[i][j]表示以i为起点长度为2^j的区间里的最大/小值。
int Log2[N];     // 预处理的log2[]取整

// getSA()

void init() {
    // 预处理Log2[]
    Log2[1] = 0;
    for (int i = 2; i < N; ++i)
        Log2[i] = Log2[i / 2] + 1;
}

// O(n)求height数组
void getHeight() {
    int i, j, k;
    // 预处理height
    for (i = 1, k = 0; i <= n; ++i) {
        k -= k > 0;                               // ht[rk[i]] >= ht[rk[i]-1] - 1 且 ht[] >= 0
        while (s[i + k] == s[sa[rk[i] - 1] + k])  // 暴力求lcp
            ++k;
        ht[rk[i]] = k;
    }

    // 预处理rmq
    for (i = 1; i <= n; ++i)
        rmq[i][0] = ht[i];
    k = Log2[n];
    for (j = 1; j <= k; ++j)
        for (i = 1; i <= n; ++i)
            rmq[i][j] = min(rmq[i][j - 1], rmq[i + (1 << (j - 1))][j - 1]);
}

// 求后缀x和后缀y的lcp。RMQ问题
int lcp(int x, int y) {
    if (x == y)  // 自身和自身的lcp等于自身
        return n - x + 1;
    if (rk[x] > rk[y])
        swap(x, y);
    x = rk[x] + 1, y = rk[y];  // 注意是height[ rk[x]+1 .. rk[y] ]
    int k = Log2[y - x + 1];
    return min(rmq[x][k], rmq[y - (1 << k) + 1][k]);
}

int main() {
    init();
    int i, x, y;
    scanf("%s", s + 1);
    n = strlen(s + 1);
    getSA(), getHeight();
    while (1) {
        scanf("%d%d", &x, &y);
        int len = lcp(x, y);
        for (i = 0; i < len; ++i)
            printf("%c", s[x + i]);
        printf("\n");
    }

    return 0;
}
\end{lstlisting}
    \subsection{height数组比较子串}
        假设需要比较的是 $A=S[a..b]$ 和 $B=S[c..d]$ 的大小关系。
        若 $lcp(a, c)\ge\min(|A|, |B|)$ ， $|A|<|B|\iff A<B$ (谁长谁大，等长相等)。
        否则， $rk[a]< rk[c]\iff A<B$ 。
\begin{lstlisting}
// 比较子串s[a..b]和s[c..d]，大于返回正数，等于返回0，小于返回负数
int subCmp(int a, int b, int c, int d) {
    int A = b - a + 1, B = d - c + 1;
    if (lcp(a, c) >= min(A, B))  //lcp长度大于等于较短串
        return A - B;
    return rk[a] - rk[c];  // 否则直接比较两后缀的rk
}
\end{lstlisting}
    \subsection{height数组求本质不同的子串个数}
        \subsubsection{本质不同的子串个数}
            子串就是后缀的前缀，所以可以枚举每个后缀，计算前缀总数，再减掉重复。\\
            “前缀总数”其实就是子串个数，为 $n(n+1)/2$ 。\\
            如果按后缀排序的顺序枚举后缀，每次新增的子串就是除了与上一个后缀的 LCP 剩下的前缀。这些前缀一定是新增的，
            否则会破坏 $lcp(sa[i],sa[j])=\min\{height[i+1..j]\}$ 的性质。只有这些前缀是新增的，因为 LCP 部分在枚举上一个前缀时计算过了。\\
            所以答案为：$\frac{n(n+1)}{2}-\sum\limits_{i=2}^nheight[i]$ 
\begin{lstlisting}
// O(n)求本质不同的子串个数
int diff() {
    int sum = n * (n + 1) / 2, i;
    for (i = 1; i <= n; ++i)
        sum -= ht[i];
    return sum;
}
\end{lstlisting}
        \subsubsection{每个出现次数的本质不同的子串个数}
            令$app[i]$表示恰好出现$i$次的不同子串个数。$last[i]$是一个滚动数组，表示比当前后缀排名小1的后缀的每个前缀已经
            出现的次数。本质思想和上面一样，上面是把所有$height$合起来了，这里需要每一个后缀分开来求
\begin{lstlisting}
// O(n^2)求每个出现次数的本质不同的子串个数
void diff() {
    int i, j;
    for (i = 1; i <= n; ++i) {
        int len = n - sa[i] + 1;  // 当前前缀长度
        for (j = 1; j <= ht[i]; ++j) {
            --app[last[j]];  // 排名更小的后缀中对应的前缀在当前后缀中再次出现了，所以更新app[]，并且为下一个排名更新last
            ++last[j];
            ++app[last[j]];
        }
        for (; j <= len; ++j)  // 初次出现的子串
            last[j] = 1, ++app[1];
    }
}
\end{lstlisting}
    \subsection{height数组求至少出现k次的最长子串(可重叠)}
        求一个串中至少出现k次的最长子串。\\\\
        出现至少 $k$ 次意味着后缀排序后有至少连续 $k$ 个后缀的 LCP 是这个子串。\\
        所以，求出每相邻 $k-1$ 个 $height$ 的最小值，再求这些最小值的最大值就是答案。\\
        可以使用单调队列 $O(n)$ 解决，但使用其它方式也足以 AC。
\begin{lstlisting}
/*
题：洛谷 P2852 [USACO06DEC]牛奶模式Milk Patterns
注意虽然元素个数n<=2e4，但是其值域为[0,1e6]。
值域包含0，那么0就不能作为结束符，故设终结符为-1
*/
deque<pair<int, int>> q;  // 单调队列
int solve() {
    int ans = 0, i;
    for (i = 1; i <= n; ++i) {
        while (!q.empty() && q.back().second > ht[i])
            q.pop_back();
        q.push_back({i, ht[i]});
        if (q.front().first <= i - k + 1)
            q.pop_front();
        if (i >= k)
            ans = max(ans, q.front().second);
    }
    return ans;
}
\end{lstlisting}
        若改为恰好出现k次，基本做法不变。令$mn=\min\{ht[i+1\dots i+k-1]\}$，只要$ht[i]\le mn$ 且 $ht[i+k]\le mn$，则当前的$mn$就是符合条件的。
    \subsection{height数组求不重叠的最长重复子串}
        先二分答案,把题目变成判定性问题:判断是否存在两个长度为 len 的子串是相同的,且不重叠。解决这个问题的关键还是利用
        height 数组。把排序后的后缀分成若干组,其中每组的后缀之间的 height 值都不小于 len。（表示当前组中存在长度为len的重复子串）\\
        然后对于每组后缀,只须判断每个后缀的 sa 值的最大值和最小值之差是否不小于 len。（差值不小于len也就不会重叠）
\begin{lstlisting}
// 返回不重叠的最长重复出现的子串的长度
int solve() {
    int mx, mn, i, l = 1, r = n, mid, ans = 0, ok;  // mx和mn是每组后缀最大和最小的后缀起点
    while (l <= r) {
        ok = mx = mn = 0;
        mid = (l + r) / 2;                             // 当前长度
        for (i = 1, ht[n + 1] = 0; i <= n + 1; ++i) {  // 为了处理最后一组，这里做到了n+1。所以要注意初始化问题
            if (ht[i] < mid) {                         // 已经到了下一个分组，结算上一分组
                if (mx - mn >= mid)                    // 不重叠
                    ans = max(ans, mid), ok = 1;
                mx = mn = sa[i];
            }
            mx = max(mx, sa[i]), mn = min(mn, sa[i]);
        }
        if (ok)  // 若存在这一长度的符合条件的子串
            l = mid + 1;
        else
            r = mid - 1;
    }
    return ans;
}
\end{lstlisting}
    \subsection{height数组求最长回文子串}
        穷举每一位,然后计算以这个字符为中心的最长回文子串。注意这里要分两
        种情况,一是回文子串的长度为奇数,二是长度为偶数。两种情况都可以转化为
        求一个后缀和一个反过来写的后缀的最长公共前缀。具体的做法是:将整个字符
        串反过来写在原字符串后面,中间用一个特殊的字符隔开。这样就把问题变为了
        求这个新的字符串的某两个后缀的最长公共前缀。
\begin{lstlisting}
// 返回最长回文串的长度
int palindr() {
    s[n + 1] = 1;                               // 介于正串和反串之间的分隔符
    reverse_copy(s + 1, s + 1 + n, s + n + 2);  // 拼接反串
    n = n * 2 + 1;
    getSA(), getHeight();
    n = (n - 1) / 2;
    int i, ans = 1;
    for (i = 1; i <= n; ++i) {
        if (1 < i && i < n) {  //奇回文串
            int len = lcp(i + 1, 2 * n + 1 - i + 2) * 2 + 1;
            ans = max(ans, len);
        }
        if (i < n) {  // 偶回文串
            int len = lcp(i + 1, 2 * n + 1 - i + 1) * 2;
            ans = max(ans, len);
        }
    }
    return ans;
}
\end{lstlisting}
    \subsection{height数组求循环节}
        做法比较简单,穷举字符串 S 的长度 k,然后判断是否满足。判断的时候,
        先看字符串 L 的长度能否被 k 整除,再看 suffix(1)和 suffix(k+1)的最长公共
        前缀是否等于 n-k。在询问最长公共前缀的时候,suffix(1)是固定的,所以 RMQ
        问题没有必要做所有的预处理,只需求出height数组中的每一个数到
        height[rank[1]]之间的最小值即可。整个做法的时间复杂度为 O(n)。
        显然，\textbf{前缀函数}更简单高效
    \subsection{height数组求重复次数最多的循环子串}
        先穷举长度 L,然后求长度为 L 的子串最多能连续出现几次。首先连续出现
        1 次是肯定可以的,所以这里只考虑至少 2 次的情况。假设在原字符串中连续出
        现 2 次,记这个子字符串为 S,那么 S 肯定包括了字符 r[0], r[L], r[L*2],
        r[L*3], ......中的某相邻的两个。所以只须看字符 r[L*i]和 r[L*(i+1)]往前和
        往后各能匹配到多远,记这个总长度为 K,那么这里连续出现了 K/L+1 次。最后
        看最大值是多少。
\begin{lstlisting}
// 返回最多出现的次数
int solve() {
    int ans = 1, len, i;  // 最少出现一次
    s[n + 1] = 1;
    reverse_copy(s + 1, s + 1 + n, s + 2 + n);
    n = n * 2 + 1;
    getSA(), getHeight();
    n /= 2;
    for (len = 1; len <= n; ++len) {                                                                                              // 穷举长度
        for (i = 0; 1 + (i + 1) * len <= n; ++i) {                                                                                // 穷举包含点
            int tot = lcp(1 + i * len, 1 + (i + 1) * len) + lcp(2 * n + 2 - (1 + i * len), 2 * n + 2 - (1 + (i + 1) * len)) - 1;  // 向前向后总共匹配了多少
            ans = max(ans, tot / len + 1);
        }
    }
    return ans;
}
\end{lstlisting}
    \subsection{height数组求最长公共子串}
        给定两个字符串 A 和 B,求最长公共子串。\\
        算法分析:\\
        字符串的任何一个子串都是这个字符串的某个后缀的前缀。求 A 和 B 的最长
        公共子串等价于求 A 的后缀和 B 的后缀的最长公共前缀的最大值。如果枚举 A
        和 B 的所有的后缀,那么这样做显然效率低下。由于要计算 A 的后缀和 B 的后缀
        的最长公共前缀,所以先将第二个字符串写在第一个字符串后面,中间用一个没
        有出现过的字符隔开,再求这个新的字符串的后缀数组。观察一下,看看能不能
        从这个新的字符串的后缀数组中找到一些规律。以 A=“aaaba”,B=“abaa”为
        例,如图 8 所示。那么是不是所有的 height 值中的最大值就是答案呢?不一定!
        有可能这两个后缀是在同一个字符串中的,所以\textbf{实际上只有当suffix(sa[i-1])和
        suffix(sa[i])不是同一个字符串中的两个后缀时,height[i]才是满足条件的。
        而这其中的最大值就是答案。}记字符串 A 和字符串 B 的长度分别为|A|和|B|。求
        新的字符串的后缀数组和 height 数组的时间是 O(|A|+|B|),然后求排名相邻但
        原来不在同一个字符串中的两个后缀的height值的最大值,时间也是
        O(|A|+|B|),所以整个做法的时间复杂度为 O(|A|+|B|)。时间复杂度已经取到
        下限,由此看出,这是一个非常优秀的算法。
\begin{lstlisting}
/*
t1和t2是两个输入串，它们的长度是len1和len2，将它们拼接成新字符串s(中间加一个分隔符)
*/
// 返回最长公共子串的长度
int lcs() {
    strcpy(s + 1, t1 + 1);
    s[len1 + 1] = '$';  // 分隔符
    strcpy(s + len1 + 2, t2 + 1);
    n = len1 + 1 + len2;  // 拼接串的长度
    getSA(), getHeight();
    int i, ans = 0, p;  // ans是长度，p是起始位置
    for (i = 2; i <= n; ++i) {
        int x = sa[i], y = sa[i - 1];
        if (x > y)
            swap(x, y);
        if (x <= len1 && y > len1)  // 分布在分隔符两侧，即属于不同串
            if (ans < ht[i])
                ans = ht[i], p = x;
    }

    return ans;
}
\end{lstlisting}
    \subsection{小常数模板}
        相比上面常数更小。\\
        关键注意几点：\\
        1. 首先将字符数组s[]\textbf{转换}为int型的r[]\\
        2. da()中r[]是从0到n-1，且要求r[n-1]为0，所有r[i]小于形参m。所以，我们传入的\textbf{形参要做一些变化}。\\
        3. 在这之后，所有的一切（下标、值域等）都和原模板一模一样。
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;
char s[N];
int r[N], n;              // 输入数组及其长度
int sa[N], rk[N], ht[N];  // 后缀数组，rank数组，height数组
// wa/wb是为da()开辟的；wv[i]相当于第一关键字的rk[i]；bs是基数排序的前缀和。（内部）
int wa[N], wb[N], wv[N], bs[N];
int cmp(int* r, int a, int b, int l) {  // 去重（内部）
    return r[a] == r[b] && r[a + l] == r[b + l];
}
// r[0..n-1]是待排序数组；sa[1..n]后缀数组；n是r[]的长度；m是r[]的最大值+1
void da(int* r, int* sa, int n, int m) {
    int i, j, p, *x = wa, *y = wb, *t;
    for (i = 0; i < m; i++)
        bs[i] = 0;
    for (i = 0; i < n; i++)
        bs[x[i] = r[i]]++;
    for (i = 1; i < m; i++)
        bs[i] += bs[i - 1];
    for (i = n - 1; i >= 0; i--)
        sa[--bs[x[i]]] = i;
    for (j = 1, p = 1; p < n; j *= 2, m = p) {
        for (p = 0, i = n - j; i < n; i++)
            y[p++] = i;
        for (i = 0; i < n; i++)
            if (sa[i] >= j)
                y[p++] = sa[i] - j;
        for (i = 0; i < n; i++)
            wv[i] = x[y[i]];
        for (i = 0; i < m; i++)
            bs[i] = 0;
        for (i = 0; i < n; i++)
            bs[wv[i]]++;
        for (i = 1; i < m; i++)
            bs[i] += bs[i - 1];
        for (i = n - 1; i >= 0; i--)
            sa[--bs[wv[i]]] = y[i];
        for (t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i < n; i++)
            x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;
    }
    // 比原模板多出这两行是为了将下标从0..n-1映射为1..n。i<n是因为形参传的长度比实际长度大1（为了满足r[n+1]=0）
    for (i = 1; i < n; ++i)
        ++sa[i];
    // 预处理rank
    for (i = 1; i < n; ++i)
        rk[sa[i]] = i;
    return;
}

// O(n)求height数组
void getHeight(int r[], int sa[], int rk[], int ht[], int n) {
    int i, k;
    // 预处理height
    for (i = 1, k = 0; i <= n; ++i) {
        k -= k > 0;                               // ht[rk[i]] >= ht[rk[i]-1] - 1 且 ht[] >= 0
        while (r[i + k] == r[sa[rk[i] - 1] + k])  // 暴力求lcp
            ++k;
        ht[rk[i]] = k;
    }
}

int main() {
    int i, mx;  // mx是r[]中的最大值
    cin >> s + 1;
    n = strlen(s + 1);

    // 关键就是这几行
    for (i = 1; i <= n; ++i)
        r[i] = s[i], mx = max(mx, r[i]);
    r[n + 1] = 0;                  // 规定r[n+1]为0
    da(r + 1, sa, n + 1, mx + 1);  // 这里注意是n+1,mx+1。填r+1是为了在接下来的处理中可以当成下标从1开始

    // 下面下标统一为 r[1..n]  sa[1..n]=[1..n]  rk[1..n]=[1..n]   (与原模板一致)

    getHeight(r, sa, rk, ht, n);

    for (i = 1; i <= n; ++i)
        cout << sa[i] << " ";
    cout << endl;
    for (i = 1; i <= n; ++i)
        cout << rk[i] << " ";
    cout << endl;
    for (i = 1; i <= n; ++i)
        cout << ht[i] << " ";
    cout << endl;

    return 0;
}

/*
aabaaaab
4 5 6 1 7 2 8 3
4 6 8 1 2 3 5 7
0 3 2 3 1 2 0 1
*/
\end{lstlisting}
    \subsection{DC3算法}
        与小常数模板基本一样。不同的是dc3()会递归，所以预处理rk不能放在dc3()内
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

#define F(x) ((x) / 3 + ((x) % 3 == 1 ? 0 : tb))
#define G(x) ((x) < tb ? (x)*3 + 1 : ((x)-tb) * 3 + 2)
const int N = 3e5 + 10;
char s[N];
int r[N], n;
int sa[N], rk[N], ht[N];
int wa[N], wb[N], wv[N], bs[N];
int c0(int* r, int a, int b) {
    return r[a] == r[b] && r[a + 1] == r[b + 1] && r[a + 2] == r[b + 2];
}
int c12(int k, int* r, int a, int b) {
    if (k == 2)
        return r[a] < r[b] || r[a] == r[b] && c12(1, r, a + 1, b + 1);
    else
        return r[a] < r[b] || r[a] == r[b] && wv[a + 1] < wv[b + 1];
}
void sort(int* r, int* a, int* b, int n, int m) {
    int i;
    for (i = 0; i < n; i++)
        wv[i] = r[a[i]];
    for (i = 0; i < m; i++)
        bs[i] = 0;
    for (i = 0; i < n; i++)
        bs[wv[i]]++;
    for (i = 1; i < m; i++)
        bs[i] += bs[i - 1];
    for (i = n - 1; i >= 0; i--)
        b[--bs[wv[i]]] = a[i];
    return;
}
void dc3(int* r, int* sa, int n, int m) {
    int i, j, *rn = r + n, *san = sa + n, ta = 0, tb = (n + 1) / 3, tbc = 0, p;
    r[n] = r[n + 1] = 0;
    for (i = 0; i < n; i++)
        if (i % 3 != 0)
            wa[tbc++] = i;
    sort(r + 2, wa, wb, tbc, m);
    sort(r + 1, wb, wa, tbc, m);
    sort(r, wa, wb, tbc, m);
    for (p = 1, rn[F(wb[0])] = 0, i = 1; i < tbc; i++)
        rn[F(wb[i])] = c0(r, wb[i - 1], wb[i]) ? p - 1 : p++;
    if (p < tbc)
        dc3(rn, san, tbc, p);
    else
        for (i = 0; i < tbc; i++)
            san[rn[i]] = i;
    for (i = 0; i < tbc; i++)
        if (san[i] < tb)
            wb[ta++] = san[i] * 3;
    if (n % 3 == 1)
        wb[ta++] = n - 1;
    sort(r, wb, wa, ta, m);
    for (i = 0; i < tbc; i++)
        wv[wb[i] = G(san[i])] = i;
    for (i = 0, j = 0, p = 0; i < ta && j < tbc; p++)
        sa[p] = c12(wb[j] % 3, r, wa[i], wb[j]) ? wa[i++] : wb[j++];
    for (; i < ta; p++)
        sa[p] = wa[i++];
    for (; j < tbc; p++)
        sa[p] = wb[j++];
    return;
}

// O(n)求height数组
void getHeight(int r[], int sa[], int rk[], int ht[], int n) {
    int i, k;
    // 预处理height
    for (i = 1, k = 0; i <= n; ++i) {
        k -= k > 0;                               // ht[rk[i]] >= ht[rk[i]-1] - 1 且 ht[] >= 0
        while (r[i + k] == r[sa[rk[i] - 1] + k])  // 暴力求lcp
            ++k;
        ht[rk[i]] = k;
    }
}

// 初始化sa[] rk[] ht[]。  r[]是拼接后的数组  len是r[]的长度  mx是r[]中最大的值
void initSaRkHt(int r[], int len, int mx, int sa[], int rk[], int ht[]) {
    int i;
    dc3(r + 1, sa, len + 1, mx + 1);  // 这里注意是len+1,mx+1。填r+1是为了在接下来的处理中可以当成下标从1开始
    // 比原模板多出这两行是为了将下标从0..n-1映射为1..n
    for (i = 1; i <= len; ++i)
        ++sa[i];
    // 预处理rank
    for (i = 1; i <= len; ++i)
        rk[sa[i]] = i;
    // 下面下标统一为 r[1..n]  sa[1..n]=[1..n]  rk[1..n]=[1..n]   (与原模板一致)
    getHeight(r, sa, rk, ht, len);
}

int main() {
    int i, mx;  // mx是r[]中的最大值
    cin >> s + 1;
    n = strlen(s + 1);

    // 关键就是这几行
    for (i = 1; i <= n; ++i)
        r[i] = s[i], mx = max(mx, r[i]);
    r[n + 1] = 0;  // 规定r[n+1]为0
    initSaRkHt(r, n, mx, sa, rk, ht);

    for (i = 1; i <= n; ++i)
        cout << sa[i] << " ";
    cout << endl;
    for (i = 1; i <= n; ++i)
        cout << rk[i] << " ";
    cout << endl;
    for (i = 1; i <= n; ++i)
        cout << ht[i] << " ";
    cout << endl;

    return 0;
}

/*
aabaaaab
4 5 6 1 7 2 8 3
4 6 8 1 2 3 5 7
0 3 2 3 1 2 0 1
*/
\end{lstlisting}
    \subsection{height数组求不小于k个字符串的最长子串}
        给定 n 个字符串,求出现在不小于 k 个字符串中的最长子串。\\
        将 n 个字符串连起来,中间用不相同的且没有出现在字符串中的字符隔开,
        求后缀数组。然后二分答案,用和例 3 同样的方法将后缀分成若干组,判断每组
        的后缀是否出现在不小于 k 个的原串中。这个做法的时间复杂度为 O(nlogn)。
\begin{lstlisting}
string s[SN];
int bel[N];    // 每个后缀的所属
bool vis[SN];  // 标记分组是否存在该原串
int tmp[SN];   // 记录vis[]中哪些被置1

// n个字符串；不小于k个；拼接总长len
int solve(int n, int k, int len) {
    memset(vis, 0, sizeof(vis));
    int cnt = 0, i, l = 1, r = SL, mid, ans = 0, ok;  // cnt是所属不同串的个数
    while (l <= r) {
        ok = 0;
        mid = (l + r) / 2;                                 // 当前长度
        for (i = 1, ht[len + 1] = 0; i <= len + 1; ++i) {  // 为了处理最后一组，这里做到了n+1。所以要注意初始化问题
            if (ht[i] < mid) {                             // 已经到了下一个分组，结算上一分组
                if (cnt >= k)
                    ans = max(ans, mid), ok = 1;
                while (cnt)
                    vis[tmp[cnt--]] = 0;
            }
            if (i <= len && bel[sa[i]] && vis[bel[sa[i]]] == 0)
                vis[tmp[++cnt] = bel[sa[i]]] = 1;
        }
        if (ok)
            l = mid + 1;
        else
            r = mid - 1;
    }
    return ans;
}

int main() {
    int i, j, mx, n, k, len;  // mx是r[]中的最大值，n个字符串，要求不小于k个
    cin >> n >> k;
    for (i = 1; i <= n; ++i)
        cin >> s[i];

    // 关键就是这几行
    mx = len = 0;
    for (i = 1; i <= n; ++i) {
        for (j = 0; j < s[i].length(); ++j)
            r[++len] = s[i][j] + n, mx = max(mx, r[len]), bel[len] = i;  // bel[]每一个后缀属于哪个串
        r[++len] = i, bel[len] = 0;                                      // 分隔符要求不相同，否则height数组会出错
    }
    r[len--] = 0;                     // 上面末尾多加了个1，改为0，len-1
    initSaRkHt(r, len, mx, sa, rk, ht);

    cout << solve(n, k, len) << endl;

    return 0;
}
\end{lstlisting}
    \subsection{height数组求在每个串中都不相交的出现两次的最长子串}
        给定 n 个字符串,求在每个字符串中至少出现两次且不重叠的最长子串。\\
        做法和上题大同小异,也是先将 n 个字符串连起来,中间用不相同的且没有
        出现在字符串中的字符隔开,求后缀数组。然后二分答案,再将后缀分组。判断
        的时候,要看是否有一组后缀在每个原来的字符串中至少出现两次,并且在每个
        原来的字符串中,后缀的起始位置的最大值与最小值之差是否不小于当前答案
        (判断能否做到不重叠,如果题目中没有不重叠的要求,那么不用做此判断)。
        这个做法的时间复杂度为 O(nlogn)。
\begin{lstlisting}
string s[SN];
int bel[N];      // 每个后缀的所属
int pos[SN][2];  // 出现的最开始位置和最末尾位置
int tmp[SN];     // 子串已经在哪些串中出现
// n个字符串；拼接总长len
int solve(int n, int len) {
    // memset(pos, 0, sizeof(pos)); // 初始化
    int cnt = 0, i, l = 1, r = SL, mid, ans = 0, ok;  // cnt是所属不同串的个数
    for (i = 0; i <= n; ++i)
        pos[i][0] = 1e9, pos[i][1] = 0;  // 初始化，最小值赋最大，最大值赋最小
    while (l <= r) {
        ok = 0;                                            // 标记当前长度下是否可以产生答案
        mid = (l + r) / 2;                                 // 当前长度
        for (i = 1, ht[len + 1] = 0; i <= len + 1; ++i) {  // 为了处理最后一组，这里做到了n+1。所以要注意初始化问题
            if (ht[i] < mid) {                             // 已经到了下一个分组，结算上一分组
                if (cnt == n) {                            // 若n个串中都出现了
                    bool flag = 1;
                    for (int j = 1; j <= n; ++j)
                        if (pos[j][1] - pos[j][0] < mid)  // 判断是否重叠
                            flag = 0;
                    if (flag)  //
                        ans = max(ans, mid), ok = 1;
                }
                while (cnt)
                    pos[tmp[cnt]][0] = 1e9, pos[tmp[cnt]][1] = 0, cnt--;
            }
            if (i <= len && bel[sa[i]]) {     // 过滤分隔符
                if (pos[bel[sa[i]]][1] == 0)  // 该串是第一次出现
                    tmp[++cnt] = bel[sa[i]];
                pos[bel[sa[i]]][0] = min(pos[bel[sa[i]]][0], sa[i]);  // 更新最大最小值
                pos[bel[sa[i]]][1] = max(pos[bel[sa[i]]][1], sa[i]);
            }
        }
        if (ok)
            l = mid + 1;
        else
            r = mid - 1;
    }
    return ans;
}
// main函数基本与上一个一模一样
\end{lstlisting}