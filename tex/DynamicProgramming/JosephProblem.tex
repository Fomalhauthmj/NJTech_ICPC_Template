\section{约瑟夫问题}
    $n$个人标号$0,1,\dots,n-1$。逆时针站成一圈，从0号开始，每一次从当前的人逆时针数m个，然后让这个人出局。问最后剩下的人是谁。\\
    参考：https://fancypei.github.io/JosephusProblem/
    \subsection{递推法}
        时间$O(n)$，空间$O(1)$\\
        令$f(n)$表示n个人最后的幸存者编号，则递推方程为：
        $$f(n)=(f(n-1)+m)\bmod n$$
        初始条件$f(1)=0$
\begin{lstlisting}
// 共n个人，编号从0到n-1，从编号为0的人开始报数，每报到m的人被抬走(从1开始报数)。返回最后存活的人的编号
inline int solve1(int n, int m) {
    int i, ret = 0;
    for (i = 2; i <= n; i++)
        ret = (ret + m) % i;
    return ret;
}
\end{lstlisting}
    \subsection{另类递归}
        时间$O(logN)$，空间$O(logN)$\\
        一次去掉$\left \lfloor \frac{n}{m} \right \rfloor$个数，其中n是当前剩余个数，m不变
\begin{lstlisting}
// 时空O(logN)
inline int solve0(int n, int m) {
    if (n == 1)
        return 0;
    if (n < m)
        return (solve0(n - 1, m) + m) % n;  // 类似于O(N)递推的f(n)=(f(n-1)+m)%n
    int s = solve0(n - n / m, m) - n % m;
    return s < 0 ? s + n : s + s / (m - 1);
}
\end{lstlisting}
    \subsection{终极方法}
        时间$O(logN)$，空间$O(1)$
        这个方法同时还解决了扩展约瑟夫问题，即第k个被抬走的人的编号是什么？
\begin{lstlisting}
// 时间O(logN)，空间O(1)
// 共n人，数m个数，第k个被抬走的(k取[0,n-1])，返回0~n-1中的一个数
inline int solve(int n, int m, int k) {
    int i;
    for (i = (k + 1) * m - 1; i >= n; i = (i - n) + (i - n) / (m - 1))
        ;
    return i;
}
\end{lstlisting}

\section{反向约瑟夫问题}
    提问：共n人，数m个数，编号为p的人第几个被抬走？
    \subsection{解法}
        最简单的还是模拟，用双端队列即可。\\
        还有一种方法，时间$O(MlogN)$。\\
        这个方法隐含在上面“终极方法”的推导过程中，我们固定p点，看每次p报数之前几个人被抬走以及p在本次报数中是否被抬走。
\begin{lstlisting}
// n个人，编号为1~n，报m个数(从1到m)，编号为p的人是第几个被抬走的，返回1~n中的一个数
inline int solve(int n, int m, int p) {
    // a是每次p报数之前被抬走的人数
    int a = p / m;
    // 如果整除则代表p在本次报数就是那个被抬走的人
    while (p % m) {
        // 若本次p没被抬走，那么下一次p是第p+n-a个报数的人
        p = p + n - a;
        // 下一次p报数之前被抬走的人数
        a = p / m;
    }
    // 返回被抬走的人数
    return a;
}
\end{lstlisting}