\section{树形动态规划}

\subsection{加分二叉树}
    \subsubsection{问题描述}
        设一个n个节点的二叉树tree的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：\\
        subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数\\
        若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。\\
        试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；\\
        （1）tree的最高加分\\
        （2）tree的前序遍历
    \subsubsection{输入格式}
        第1行：一个整数n（n＜30），为节点个数。\\
        第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。
    \subsubsection{输出格式}
        第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。\\
        第2行：n个用空格隔开的整数，为该树的前序遍历。
    \subsubsection{思路}
        这道题看上去是树形DP，但仔细思考，我们发现很难依据中序遍历建出树。
        但中序遍历有其独特之处，即一旦根被确定，则左右子树也被确定。\\
        所以我们应该用区间DP来解决这道题。\\
        $f(i,j)$:选i到j的节点作为一颗子树最大的得分
        $$f(i,j)=\max_{i \leq k \leq j}{\{f(i,k-1)*f(k+1,j)+f(k,k)\}}$$
        由题意，当$i>j$，$f(i,j)=1$为空节点。\\
        前序遍历就是重新用dfs走一遍：每次找到使$f(i,j)$最大的$k$，然后以$k$为分界向左右两边递归。

\subsection{洛谷P2015 二叉苹果树}
    \subsubsection{问题描述}
        有一棵苹果树，如果树枝有分叉，一定是分2叉（就是说没有只有1个儿子的结点）这棵树共有N个结点（叶子点或者树枝分叉点），编号为1-N,树根编号一定是1。我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。\\
        给定需要保留的树枝数量，求出最多能留住多少苹果。
    \subsubsection{输入格式}
        第1行2个数，N和Q(1<=Q<= N,1<N<=100)。\\
        N表示树的结点数，Q表示要保留的树枝数量。接下来N-1行描述树枝的信息。\\
        每行3个整数，前两个是它连接的结点的编号。第3个数是这根树枝上苹果的数量。\\
        每根树枝上的苹果不超过30000个。
    \subsubsection{输出格式}
        剩余苹果的最大数量。
    \subsubsection{思路}
        $f(i,j)$表示以i为节点的根保留k条边的最大值
        接下来对每一个节点分类讨论，共三种情况：\\
        1.全选左子树\\
        2.全选右子树\\
        3.左右子树都有一部分\\
        为了方便，我们设左儿子为ls，右儿子为rs，连接左儿子的边为le，连接右儿子的边为re\\
        $$f(i,j)=\max{\{f(ls,j-1)+le, f(rs,j-1)+re, \max_{0 \leq k \leq j-2}{\{f(ls,k)+f(rs,j-2-k)\}}+le+re\}}$$

\subsection{最大利润}
    \subsubsection{问题描述}
        政府邀请了你在火车站开饭店，但不允许同时在两个相连接的火车站开。任意两个火车站有且只有一条路径，每个火车站最多有50个和它相连接的火车站。\\
        告诉你每个火车站的利润，问你可以获得的最大利润为多少。\\
        最佳投资方案是在1，2，5，6这4个火车站开饭店可以获得利润为90
    \subsubsection{输入格式}
        第一行输入整数N(<=100000)，表示有N个火车站，分别用1，2。。。，N来编号。接下来N行，每行一个整数表示每个站点的利润，接下来N-1行描述火车站网络，每行两个整数，表示相连接的两个站点。
    \subsubsection{输出格式}
        输出一个整数表示可以获得的最大利润。
    \subsubsection{思路}
        这道题虽然是多叉树，但状态仍然是比较简单的。\\
        对于某个结点，如果选择该节点，则该节点的所有儿子都不能选，如果不选该节点，则它的儿子可选可不选。\\
        所以，我们令$f(i)$表示以i节点为根的子树中选i的最大利润，$h(i)$表示以i节点为根的子树中不选i的最大利润。a[i]是i本身的利润，j是i的儿子
        $$f(i)=a[i]+\sum_{j}{h(j)}$$
        $$h(i)=\sum_{j}{\max{\{f(j),h(j)\}}}$$

\subsection{洛谷P2014 选课}
    \subsubsection{问题描述}
        学校实行学分制。每门的必修课都有固定的学分，同时还必须获得相应的选修课程学分。学校开设了N（N<300）门的选修课程，每个学生可选课程的数量M是给定的。学生选修了这M门课并考核通过就能获得相应的学分。\\
        在选修课程中，有些课程可以直接选修，有些课程需要一定的基础知识，必须在选了其它的一些课程的基础上才能选修。例如《Frontpage》必须在选修了《Windows操作基础》之后才能选修。我们称《Windows操作基础》是《Frontpage》的先修课。每门课的直接先修课最多只有一门。两门课也可能存在相同的先修课。每门课都有一个课号，依次为1，2，3，…。\\
        你的任务是为自己确定一个选课方案，使得你能得到的学分最多，并且必须满足先修课优先的原则。假定课程之间不存在时间上的冲突。
    \subsubsection{输入格式}
        输入文件的第一行包括两个整数N、M（中间用一个空格隔开），其中$1\leq N\leq 300,1\leq M\leq N$。
        以下N行每行代表一门课。课号依次为1，2，…，N。每行有两个数（用一个空格隔开），第一个数为这门课先修课的课号（若不存在先修课则该项为0），第二个数为这门课的学分。学分是不超过10的正整数。
    \subsubsection{输出格式}
        只有一个数：实际所选课程的学分总数。
    \subsubsection{思路一}
        分析一下，似乎也不是很难，对于某个节点，只有选择它，才能选择它的儿子们。\\
        令$f(x,i)$表示在以x结点为根的子树中选择i个点的最大学分。$f(x,1)=s[x]$，s[x]是课程x本身的学分。\\
        假设结点x有k个儿子，标号为$y_1,y_2,..,y_k$，让他们分别选$i_1,i_2,..,i_k$门课程，那么状态转移方程似乎是..
        $$f(x,i)=s[x]+\max_{i_1+i_2+..+i_k=i-1}{\sum_{1 \leq j \leq k}{f(y_j,i_j)}}$$
        好像..写不出这样的循环啊，当然，如果用dfs强行写也不是不可以，但是时间复杂度必炸。\\\\
        这时候我们要用一种类似\textbf{前缀和}的思维\\
        即，我们每dfs完一棵子树，都进行一次完整的dp更新。假设当前根结点为x，我们刚dfs完它的一棵子树y，那么我们进行如下更新（对所有i）：
        $$f(x,i)=\max_{1\leq j\leq i}{\{f(x,j)+f(y,i-j)\}}$$
        \textbf{此时$f(x,i)$表示在以x结点为根的子树中已经被dfs过的部分中选i个点的最大学分，而每次更新就像是把一棵新子树添加到答案中。}\\
        除此以外，还有一点要注意，就是我们要让\textbf{i递减更新}，因为大的i要用到之前小的i，而小的i不要用到大的i
    \subsubsection{思路二}
        先将\textbf{森林转二叉树(左孩子右兄弟)}。如何转呢？设D[x]、c[x]和b[x]分别表示x结点的父亲、左孩子和右兄弟，对于每个节点，D[x]是已知的，所以\textbf{b[x]=c[D[x]],c[D[x]]=x}。\\
        再分析，对于某个节点，如果要选其左孩子，则必须选它，而选右孩子则没有限制。\\
        令$f(x,i)$表示在以x结点为根的子树中选择i个点的最大学分。$f(x,1)=s[x]$，s[x]是课程x本身的学分。\\
        还是沿用上面\textbf{前缀和思想}，先由左孩子(ls)更新，再由右孩子(rs)\textbf{倒着}更新，两次的方程如下：
        $$f(x,i)=f(x,1)+f(ls,i-1)$$
        $$f(x,i)=\max_{0\leq j\leq i}{f(x,j)+f(rs,i-j)}$$

\subsection{HYSBZ 2427 软件安装}
    \subsubsection{题目描述}
        现在我们的手头有N个软件，对于一个软件i，它要占用Wi的磁盘空间，它的价值为Vi。我们希望从中选择一些软件安装到一台磁盘容量为M的计算机上，使得这些软件的价值尽可能大（即Vi的和最大）。\\
        但是现在有个问题：软件之间存在依赖关系，即软件i只有在安装了软件j（包括软件j的直接或间接依赖）的情况下才能正确工作（软件i依赖软件j）。幸运的是，一个软件最多依赖另外一个软件。如果一个软件不能正常工作，那么他能够发挥的作用为0。\\
        我们现在知道了软件之间的依赖关系：软件i依赖Di。现在请你设计出一种方案，安装价值尽量大的软件。一个软件只能被安装一次，如果一个软件没有依赖则Di=0，这是只要这个软件安装了，它就能正常工作。
    subsubsection{输入格式}
        第1行：N,M （0<=N<=100,0<=M<=500）
        第2行：W1,W2, … Wi, … ,Wn
        第3行：V1,V2, … Vi, … ,Vn
        第4行：D1,D2, … Di, … ,Dn
    \subsubsection{输出格式}
        一个整数，代表最大价值。
    \subsubsection{思路}
        \textbf{注意，此图可能有环}\\
        仔细读题，题中说一个软件只依赖最多一个软件，所以在一个联通分之内最多只有一个环，并且该环可以指向环以外的节点，而环以外的节点不会指向环。\\
        因此，我们可以\textbf{把环当做一个新节点}来处理，这个新节点所占空间和价值都为环内元素加和。\\
        怎么确定环及环内元素呢？我推荐\textbf{着色法(有向图为黑白灰，无向图为黑白)}。\\
        有向图中白色为未探索的点，灰色为正在探索的点，黑色为已经探索过的并且确定不成环的点。若在探索过程中遇到灰点，则说明成环。\\
        无向图中白色为未探索的点，黑色为已经探索过和正在探索的点。若在探索过程中遇到黑点，则说明成环。\\
        处理完成后，DP思路同\textit{"洛谷P2014 选课"}

\subsection{CF486D Valid Sets}
    \subsubsection{题目描述}
        给定一棵树，每个点都有一个权，现在要你选择一个连通块，问有多少种选择方法，使得连通块中的最大点权和最小点权的差值小于等于d。答案对1e9+7取模。
    \subsubsection{输入格式}
        The first line contains two space-separated integers d (0 ≤ d ≤ 2000) and n (1 ≤ n ≤ 2000).\\
        The second line contains n space-separated positive integers a1, a2, ..., an(1 ≤ ai ≤ 2000).\\
        Then the next n - 1 line each contain pair of integers u and v (1 ≤ u, v ≤ n) denoting that there is an edge between u and v. It is guaranteed that these edges form a tree.
    \subsubsection{输出格式}
        Print the number of valid sets modulo 1000000007.
    \subsubsection{思路}
        我起初的错误想法是，设$f(x,i)$和$g(x,i)$分别为以x为根的子树中最大值和最小值为i的方案数，企图通过对g和f的运算得出答案，但这是错误的，主要原因是f和g无法把范围限定住。\\
        受到前面以子树为对象思考的影响，形成了\textbf{思维惯性}，这里我们并不是以子树为对象，在一遍dfs里算出所有答案。\\
        而是\textbf{枚举}，枚举每一点x，将x作为连通块的最大值，以x为根进行dfs，求方案数。\\
        另外要注意：因为点权可能相同，所以为了避免重复计算，我们需要定序，若权值相同，让编号大的点访问编号小的，而编号小的不能访问大的。

\subsection{CF294E Shaass the Great}
    \subsubsection{题目描述}
        给一颗带边权的树，让你选一条边删除，然后在得到的两个子树中各选一个点，用原来被删除的边连起来，重新拼成一棵树。使得这棵树的所有点对的距离总和最小。\\
    \subsubsection{输入格式}
        The first line of the input contains an integer n denoting the number of cities in the empire, $(2 \leq n \leq 5000)$. The next n - 1 lines each contains three integers ai, bi and wi showing that two cities ai and bi are connected using a road of length wi, $(1 \leq a_i, b_i \leq n, a_i \neq b_i, 1 \leq w_i \leq 106)$.
    \subsubsection{输出格式}
        所有点对距离总和最优解。
    \subsubsection{思路}
        设我们要删除的边为e，以e为分界树被分割成了左右两个部分(我们称为左树和右树)，最后我们连接的两个点为vl和vr\\
        则答案为：\\
        左树内点对距离总和 + 右树内点对距离总和\\
        + 左树中所有点到vl的距离总和 * 右树中点的个数 + 右树中所有点到vr的距离总和 * 左树中点的个数\\
        + e的权重 * 左树中点的个数 * 右树中点的个数\\\\
        再观察一下，其实在删除e的情况下 左右树内点对距离总和、左右树中的点的个数、e的权重 都是不变的，变化的只有左右树中所有点到vl和vr的距离总和\\
        由此我们知道了，在删除e的情况下，答案最优的条件即为\textbf{找到 vl和vr，使得左树中所有点到vl的距离总和最小，右树中所有点到vr的距离总和最小}\\
        于是我们知道了，要得到答案，就是要求一棵树的三个值：树内点的个数、树上所有点到某一点的距离总和的最小值、树内所有点对距离总和\\
        树内点的个数最简单，不多说了，而树内所有点对的距离和也可以由树上所有点到某一点的距离和算得(即树上所有点到\textbf{每}一点的和除以2)\\\\
        下面主要考虑如何在$O(n)$的时间内求出树上所有点到每一点的距离：\\\\
        \textbf{考虑dfs，结果发现一遍dfs无论如何都不可能得到，但是可以知道以某一点x为根的子树上所有点到根x的距离总和\\
        在第一遍dfs的基础上，我们再进行一次dfs，这次dfs我们不再是自底向上更新，而是自顶向下更新，更新父节点及其以上所有的点到x的距离总和\\
        可以理解为，第一次dfs我们得到了x以下的所有点到x的距离总和，第二次dfs我们得到了x以上的所有点到x的距离总和}\\\\
        对于第二次dfs，例如我们现在在a节点上，即将去往x结点，我们需要下传给x节点的距离有哪些呢？\\
        1.a结点上面传下来的距离\\
        2.a结点上除了x分支所有旁路上的距离(由第一次dfs可以算出)\\
        3.a与x的边权\\\\
        所以最后的算法是：\textbf{枚举每一条边}，运用以上算法，求出最小值